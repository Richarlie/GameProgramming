# 生成排列并枚举
1.**枚举全部排列**
```C++
#include<cstdio>
#include<algorithm>
using namespace std;
int main(){
    int n, P[100];
    scanf("%d",&n);
    for(int i=0; i<n; i++) scanf("%d",P+i);
    sort(P,P+n);
    do{
        for(int i=0; i<n; i++) printf("%d ",P[i]);
        printf("\n");
    }while(next_permutation(P, P+n));
    return 0;
}
```
2.**用递归方法（不考虑重复数字）**
其思想就是：先输出所有以1为开头的排列（递归调用），然后输出以2为开头的排列（递归调用）······以此类推到以n为开头的排列
```C++
#include <iostream>
#include <string>
#include <vector>
using namespace std;

// 用于交换两个字符
void swap(char& a, char& b) {
    char temp = a;
    a = b;
    b = temp;
}

// 递归函数，用于生成排列
void permute(string str, int l, int r, vector<string>& result) {
    // 如果左索引等于右索引，说明已经生成了一个完整的排列
    if (l == r) {
        result.push_back(str);
    } else {
        // 遍历每个字符，将其与第一个字符交换，然后递归生成剩余部分的排列
        for (int i = l; i <= r; i++) {
            swap(str[l], str[i]); // 交换字符//这样子结合遍历起来就能把第l个位的数字进行全部遍历在此
            permute(str, l + 1, r, result); // 递归生成剩余部分的排列
            swap(str[l], str[i]); // 恢复交换，以便下次使用
        }
    }
}

int main() {
    string input;
    cout << "请输入一个数字串（不包含重复数字）: ";
    cin >> input;

    vector<string> result;
    permute(input, 0, input.length() - 1, result);

    cout << "所有排列如下：" << endl;
    for (const auto& permutation : result) {
        cout << permutation << endl;
    }

    return 0;
}
```
<!--stackedit_data:
eyJoaXN0b3J5IjpbLTExOTgwODM2OF19
-->