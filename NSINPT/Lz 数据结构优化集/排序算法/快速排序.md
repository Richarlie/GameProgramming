# 快速排序
**主要思路：**
收尾两个指针，首指针指的元素做参照值，
从尾指针开始向中心进发直至找到比参照值小的，直接两指针元素置换，首指针向中间进发一格
从首指针开始向中心进发直至找到比参照值大的，直接两指针元素置换，尾指针向中间进发一格
直到首尾指针相遇
分治递归：在相遇处分割，一直排下去，结束条件式函数传入的left>=right

```C++
void Sort(vector<int>&arr,int left,int right){
	if(left>=right)return;
	int a=left;
	int b=right;
	int ocs=arr[left];
	while(a<b){
		while(a<b&&arr[b]>=ocs) b--;
		if(a<b) swap(arr[a++],arr[b]);
		while(a<b&&arr[a]<=ocs) a++;
		if(a<b) swap(arr[a],arr[b--]);
	}
	for(int i=0;i<arr.size();i++){
		cout<<arr[i]<<" ";
	}
	cout<<endl;
	Sort(arr,left,a-1);
	Sort(arr,a+1,right);
}
```
<!--stackedit_data:
eyJoaXN0b3J5IjpbMjQ0MTg5NjM5XX0=
-->