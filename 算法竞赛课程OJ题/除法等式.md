# 除法等式
### Description

输入正整数n,按从小到大的顺序输出所有形如abcde/fghij=n的表达式，其中a~j各代表0~9中的一个数字
除了0可以重复外，其它数字不能重复，2<=n<=90000。

  
  
  

### 输入格式

多case，每行一个数字，最后一个数字是0

  
  

### 输出格式

除了最后一行0不用处理，
其它每个case，按被除数由小到大输出所有满足等式的情况
注：如果没有满足条件的等式，该case结束后，也需要输出一个空行

两个case之间用一个空行分隔

**基本思路：**
1. 获取除数的枚举范围；
2. 枚举出除数及被除数；
3. 判断（用set容器）

```C++
#include<iostream>
#include<string>
#include<set>
using namespace std;
 
bool judgevalid(string dividend_str, string divisor_str) {
    set<int> non_zero; 
 
    // 检查被除数中的非零数字是否唯一
    for (int i = 0; i < dividend_str.size(); i++) {
        int d = dividend_str[i] - '0'; // 转换为数字
        if (d == 0) continue; // 0不参与唯一性检查
        if (non_zero.count(d)) return false; // 发现重复非零数字，返回非法
        non_zero.insert(d); // 记录非零数字
    }
 
    // 检查除数中的非零数字是否唯一，且与被除数不重复
    for (int i = 0; i < divisor_str.size(); i++) {
        int d = divisor_str[i] - '0'; // 转换为数字
        if (d == 0) continue; // 0不参与唯一性检查
        if (non_zero.count(d)) return false; // 发现重复非零数字，返回非法
        non_zero.insert(d); // 记录非零数字
    }
 
    return true; // 所有非零数字唯一，0可重复，返回合法
}
 
void solve() {
    while (1) {
        cin >> n; 
        if (n == 0) break; 
        int max_divisor = 99999 / n;
 
        // 枚举所有可能的除数i（i从1开始，因为除数为0无意义）
        for (int i = 1; i <= max_divisor; i++) {
            // 处理除数：转换为5位字符串，补前导零（如i=4→"00004"）
            string divisor_post = to_string(i); 
            string divisor_str = string(5 - divisor_post.length(), '0') + divisor_post; 
 
            int dividend = n * i;
            // 处理被除数：转换为5位字符串，补前导零（如dividend=176→"00176"）
            string dividend_post = to_string(dividend); 
            string dividend_str = string(5 - dividend_post.length(), '0') + dividend_post;
 
            if (judgevalid(dividend_str, divisor_str)) {
                cout << dividend_str << "/" << divisor_str << "=" << n << "\n";
            }
        }
        cout << "\n";
    }
}
 
int main() {
    solve(); // 调用主处理函数
    return 0;
}
```
<!--stackedit_data:
eyJoaXN0b3J5IjpbNTg5Mjk5NTJdfQ==
-->