# 校OJ 1142 巡逻的士兵
- 有N个士兵站成一队列，现在需要选择几个士兵派去侦察。为了选择合适的士兵，多次进行如下操作：如果队列超过三个士兵，那么去除掉所有站立位置为奇数的士兵，或者是去除掉所有站立位置为偶数的士兵。直到不超过三个战士，他们将被送去侦察。现要求统计按这样的方法，总共可能有多少种不同的正好三个士兵去侦察的士兵组合方案。注：按上述得到少于三士兵的情况不统计。1 <= N <= 2的32次方

- **输入格式**  - 有多行，每行一个数字N，最后一行是0  
- - **输出格式**  - 对每一行的数字N，输出针对N的方案数，直到没有数字
- ### 注意事项
- 1. 题目中的“站立位置”指的是士兵在队列中的初始位置编号（从1开始）。
- 2. 每次操作可以选择去除奇数位置或偶数位置的士兵，直到剩余士兵不超过3人。
- 3. 只有恰好剩下3名士兵的情况才被计入统计结果。如果需要进一步解释题目或示例，请随时告知！

## 答案
```c
#include <iostream>
#include <unordered_map>
using namespace std;
unordered_map<unsigned long long, unsigned long long> memo;
unsigned long long calculate(unsigned long long n) {   
   if (n < 3) return 0; 
   if (n == 3) return 1;
   if (memo.find(n) != memo.end()) return memo[n]; 
   if (n % 2 == 0) {       
    unsigned long long res = 2 * calculate(n / 2); 
           memo[n] = res;
                   return res; 
                      } 
                      else {        unsigned long long a = (n - 1) / 2;        unsigned long long b = (n + 1) / 2;        unsigned long long res = calculate(a) + calculate(b);        memo[n] = res;        return res;    }}int main() {    ios::sync_with_stdio(false);    cin.tie(nullptr);        unsigned long long n;    while (cin >> n && n != 0) {        cout << calculate(n) << '\n';    }    return 0;}
<!--stackedit_data:
eyJoaXN0b3J5IjpbLTIxMzQwOTE5NzhdfQ==
-->