# 求最小特殊数字
# Description

用全部N(N<=10)个0-9的数字组成一个“有效”整数（即没有前置0的整数），
求这些组成的数中能被K(0<K<10^10)整除的最小数字。

  
  
  

### 输入格式

输入分两行，第一行输入N, K，第二行输入N个数字。

  
  

### 输出格式

输出满足条件的最小的数（不含前置0），如果没有满足条件的数输出 -1。

  
  

>输入样例
4 7
4 0 1 3

  
  

>输出样例
1043

  
  

### 提示

413 % 7 = 0， 但是有前置0，所以满足条件的最小数是 1043 % 7 = 0。
此类题目需注意特殊情况，比如n=1时,如只输入一个0，答案只能是0。
注意long long
``` C++
#include <iostream>
#include <vector>
#include <algorithm>

using namespace std;

int main() {
    int N;
    long long K;
    cin >> N >> K;

    vector<int> digits(N);
    for (int i = 0; i < N; ++i) {
        cin >> digits[i];
    }

    // 特殊情况处理
    if (N == 1) {
        if (digits[0] == 0) {
            cout << 0 << endl;
        } else {
            cout << digits[0] << endl;
        }
        return 0;
    }

    // 将数字排序，便于生成最小的排列
    sort(digits.begin(), digits.end());

    // 用于存储满足条件的最小数字
    long long minNumber = -1;

    do {
        // 跳过以 0 开头的排列
        if (digits[0] == 0) continue;

        // 将排列转换为数字
        long long num = 0;
        for (int i = 0; i < N; ++i) {
            num = num * 10 + digits[i];
        }

        // 检查是否满足条件
        if (num % K == 0) {
            if (minNumber == -1 || num < minNumber) {
                minNumber = num;
            }
        }
    } while (next_permutation(digits.begin(), digits.end()));

    // 输出结果
    if (minNumber == -1) {
        cout << -1 << endl;
    } else {
        cout << minNumber << endl;
    }

    return 0;
}

```
<!--stackedit_data:
eyJoaXN0b3J5IjpbMTQxNTU3NDA0Ml19
-->