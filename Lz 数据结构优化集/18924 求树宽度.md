# 18924 求树宽度
# 18924 二叉树的宽度

时间限制:1000MS 代码长度限制:10KB  
提交次数:0 通过次数:0

题型: 编程题 语言: G++;GCC  

### Description
二叉树的宽度指的是具有节点数目最多的那一层的节点个数。
          1
         / \
        2   3
       /     
      4     
答案为2, 第二层节点数最多，为2个节点。
### 输入格式
共n行。
第一行一个整数n，表示有n个结点，编号为1至n,结点1为树根。（1<=n<=50）
第二行至第n行，每行有两个整数x和y，表示在二叉树中x为y的父节点。x第一次出现时y为左孩子
### 输出格式

输出二叉树的宽度
### 输入样例

5
1 2
1 3
2 4
2 5

### 输出样例
2

```C++
#include <iostream>
#include <queue>
#include <vector>

using namespace std;

int main() {
    int n;
    cin >> n;
    vector<int> left_child(n + 1, -1); // 存储每个节点的左孩子，-1表示没有
    vector<int> right_child(n + 1, -1); // 存储每个节点的右孩子，-1表示没有
    vector<bool> has_left(n + 1, false); // 标记是否已经有左孩子

    // 读取输入并构建树结构
    for (int i = 0; i < n - 1; ++i) {
        int x, y;
        cin >> x >> y;
        if (!has_left[x]) {
            left_child[x] = y;
            has_left[x] = true;
        } else {
            right_child[x] = y;
        }
    }

    // BFS层次遍历
    int max_width = 0;
    if (n >= 1) {
        queue<int> q;
        q.push(1); // 根节点
        while (!q.empty()) {
            int level_size = q.size();
            max_width = max(max_width, level_size);
            for (int i = 0; i < level_size; ++i) {
                int node = q.front();
                q.pop();
                if (left_child[node] != -1) {
                    q.push(left_child[node]);
                }
                if (right_child[node] != -1) {
                    q.push(right_child[node]);
                }
            }
        }
    }
    cout << max_width << endl;
    return 0;
}
```
<!--stackedit_data:
eyJoaXN0b3J5IjpbMTQzMzkzMDgyNV19
-->