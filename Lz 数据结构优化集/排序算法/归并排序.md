# 归并排序（非递归算法）
**基本思路：**
第一个函数负责圈定归并范围
关于这个函数，有两层循环：
1. 第一层是负责数组的项数（由1升到n）
2. 第二层是负责圈定每两组数组

第二个函数负责归并的进行
```C++
// 合并两个有序子数组 arr[left...mid] 和 arr[mid+1...right]
void Merge(vector<int>& arr, int left, int mid, int right) {
    vector<int> temp(right - left + 1); // 临时数组存储合并后的结果
    int i = left, j = mid + 1, k = 0;
    // 合并两个有序子数组
    while (i <= mid && j <= right) {
        if (arr[i] <= arr[j]) {
            temp[k++] = arr[i++];
        } else {
            temp[k++] = arr[j++];
        }
    }
    // 处理左边子数组剩余的元素
    while (i <= mid) {
        temp[k++] = arr[i++];
    }
    // 处理右边子数组剩余的元素
    while (j <= right) {
        temp[k++] = arr[j++];
    }
    // 将临时数组中的元素复制回原数组
    for (i = left, k = 0; i <= right; ++i, ++k) {
        arr[i] = temp[k];
    }
}

// 非递归归并排序
void MergeSort(vector<int>& arr) {
    int n = arr.size(); // 数组大小
    for (int step = 1; step < n; step *= 2) { // 逐步增加步长
        for (int left = 0; left < n; left += step * 2) { // 每个步长下，分组合并
            int mid = left + step - 1; // 当前组的中间位置
            int right = min(left + step * 2 - 1, n - 1); // 当前组的右边界
            Merge(arr, left, mid, right); // 合并两个子数组
        }
        // 打印当前排序结果
        for (int i = 0; i < n; i++) {
            cout << arr[i] << " ";
        }
        cout << endl;
    }
}
```
<!--stackedit_data:
eyJoaXN0b3J5IjpbLTU4MDc3NTYwMyw0NDA5MDU2MTldfQ==
-->