# 18724 二叉树的遍历运算
# Description

二叉树的三种遍历都可以通过递归实现。
如果我们知道一棵二叉树的先序和中序序列，可以用递归的方法求后序遍历序列。

  
  
  

### 输入格式

两行，第一行一个字符串，表示树的先序遍历，第二行一个字符串，表示树的中序遍历。
树的结点一律用小写字母表示,且字符串长度不超过30。

  
  

### 输出格式

一个字符串，树的后序序列。

  
  

### 输入样例

abcde
bcade

##思路：##
**1.根据所给两个序列合并生成树
2.对树进行遍历，遇到非空结点则**


```C++
#include <iostream>
#include <string>
using namespace std;

typedef struct tree {
    string str;
    tree* left;
    tree* right;
} tree, *treeptr;

treeptr GetTree(string preo, int preost, int preoov, string ino, int inost, int inoov) {
    if (preost > preoov || inost > inoov) {
        return nullptr; // 递归终止条件
    }
    // 创建根节点
    treeptr T = new tree{string(1, preo[preost]), nullptr, nullptr};
    // 在中序遍历中找到根节点的位置
    int noteit = inost;
    while (noteit <= inoov && ino[noteit] != preo[preost]) {
        noteit++;
    }
    // 计算左子树的大小
    int leftsize = noteit - inost;
    // 递归创建左子树
    T->left = GetTree(preo, preost + 1, preost + leftsize, ino, inost, noteit - 1);
    // 递归创建右子树
    T->right = GetTree(preo, preost + leftsize + 1, preoov, ino, noteit + 1, inoov);
    return T;
}

void PostOrder(treeptr K, string& result) {
    if (K == nullptr) {
        return;
    }
    PostOrder(K->left, result);
    PostOrder(K->right, result);
    result += K->str; // 将当前节点的字符加入结果字符串
}

void CreateTree(string a, string b) {
    treeptr K = GetTree(a, 0, a.length() - 1, b, 0, b.length() - 1);
    string result;
    PostOrder(K, result);
    cout << result << endl; // 输出后序遍历结果
}

int main() {
    string a, b;
    cin >> a >> b;
    CreateTree(a, b);
    return 0;
}

```
<!--stackedit_data:
eyJoaXN0b3J5IjpbMTAxOTU1NDI2NF19
-->