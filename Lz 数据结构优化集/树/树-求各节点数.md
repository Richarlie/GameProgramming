# 树-求各节点数
### Desciption:
**构造二叉链表表示的二叉树：按先序次序输入二叉树中结点的值（一个字符），'#'字符表示空树，构造二叉链表表示的二叉树T,并求此二叉树中度为2的节点总数**

#### 输入格式

第一行输入先序次序二叉树中结点

  
  

#### 输出格式

第一行输出度为2的节点数
第二行输出度为1的节点数
第三行输出度为0的节点数

  
  

#### 输入样例

ABC###D##

  
  

#### 输出样例

1
1
2

```C++
#include <iostream>
#include <vector>
#include <algorithm>
#include <string>
#include <cstdlib> // 添加头文件以支持malloc和free
#define TRUE 1
#define FALSE 0
#define OK  1
#define ERROR  0
#define INFEASIBLE -1
#define OVERFLOW -2
typedef int  Status;
using namespace std;

typedef char  ElemType;
typedef struct BiTNode {
    ElemType data;
    struct BiTNode *lchild, *rchild; // 左右孩子指针
} BiTNode, *BiTree;

Status CreateBiTree(BiTree &T) {  // 算法6.4
    // 按先序次序输入二叉树中结点的值（一个字符），'#'字符表示空树，
    // 构造二叉链表表示的二叉树T。
    char ch;
    cin >> ch; // 使用cin代替scanf
    if (ch == '#') T = NULL;
    else {
        if (!(T = (BiTNode *)malloc(sizeof(BiTNode)))) return ERROR;
        else {
            T->data = ch;
            CreateBiTree(T->lchild);
            CreateBiTree(T->rchild);
        }
    }
    return OK;
} // CreateBiTree

void CountNodes(BiTree T, int &degree0, int &degree1, int &degree2) {
    // 递归统计度为0、1、2的节点数
    if (T == NULL) return;

    int left = (T->lchild != NULL);
    int right = (T->rchild != NULL);

    if (left + right == 0) degree0++; // 度为0
    else if (left + right == 1) degree1++; // 度为1
    else if (left + right == 2) degree2++; // 度为2

    CountNodes(T->lchild, degree0, degree1, degree2);
    CountNodes(T->rchild, degree0, degree1, degree2);
}

int main() {
    BiTree K;
    CreateBiTree(K);
    int degree0 = 0, degree1 = 0, degree2 = 0;
    CountNodes(K, degree0, degree1, degree2);

    cout << degree2 << "\n";
    cout << degree1 << "\n";
    cout << degree0 << "\n";

    return 0;
}
```

<!--stackedit_data:
eyJoaXN0b3J5IjpbMTIzMTk4MDcwMF19
-->