# 龙龙
### Description

在比赛的时候，1Y(1 次AC)是很值得高兴的事情。但很多大牛总会因为很弱智的错误先WA 一次，再AC。
而很多时候，这点罚时的差距使得他们与金牌无缘。弱智错误系列中最显著的就是忘记加龙龙。

龙龙外国人叫它作long long，表示64位整数，输入与输出64位整数则可以使用例如
scanf("%lld", &a)与printf("%lld", a)的形式完成。很多图论和动态规划的题目中，
虽然题目说最后输出的答案是32 位的整数，但中间计算的过程有时会超过int，这时我们就要使用龙龙了。

可惜的是，很多同学刚开始学写程序都是用VC的，在VC上是无法使用long long的，我们要用__int64
代替，输入与输出64位整数则可以使用例如scanf("%I64d", &a)与printf("%I64d", a)的形式完成。


但是提交上OJ 的时候，如果使用GCC或G++，都只支持long long，我们在提交时又得按照上边的改回来（的确挺麻烦,窘）。
为了让知道龙龙的同学们记得使用龙龙，不知道的学习使用龙龙，下边有个很简单的函数，希望大家
求出它的返回值：

long long H(int n){
    long long res = 0;
    int i;
    for(i = 1; i <= n; i=i+1 ){
        res = (res + n/i);
    }
    return res;
}

不过直接使用这个函数是会超时的，必须改造这个函数，当然这一定难不到未来的编程高手--你

  
  
  

### 输入格式

第一行是数字T(T<=1021)表示case数，接下来T 行，每行一个整数n，n是一个32 位整数（保证可以由int 表示）。

  
  

### 输出格式

函数返回值。

  
  

### 输入样例

2
5
10

  
  

### 输出样例

10
27
 
```C++
#include <stdio.h>
#include <math.h>

long long H(int n) {
    if (n <= 0) return 0;
    long long res = 0;
    int sqrt_n = sqrt(n);
    for (int i = 1; i <= sqrt_n; i++) {
        res += n / i;
    }
    // 处理剩下的部分，k从1到sqrt_n - 1
    int last_k = n / (sqrt_n + 1);
    for (int k = 1; k <= last_k; k++) {
        int count = n / k - n / (k + 1);
        res += (long long)k * count;
    }
    return res;
}

int main() {
    int T, n;
    scanf("%d", &T);
    while (T--) {
        scanf("%d", &n);
        printf("%lld\n", H(n));
    }
    return 0;
}
```
<!--stackedit_data:
eyJoaXN0b3J5IjpbLTE1MzAyNDE1MjddfQ==
-->