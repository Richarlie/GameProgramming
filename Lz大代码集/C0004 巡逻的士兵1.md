# 巡逻的士兵1
- **有N个士兵站成一队列, 现在需要选择几个士兵派去侦察。
为了选择合适的士兵, 多次进行如下操作: 如果队列超过三个士兵, 那么去除掉所有站立位置为奇数的士兵, 
或者是去除掉所有站立位置为偶数的士兵。直到不超过三个战士，他们将被送去侦察。现要求统计按这样的方法，
总共可能有多少种不同的正好三个士兵去侦察的士兵组合方案。**

- **注: 按上法得到少于三士兵的情况不统计。
1 <= N <= 2的32次方-1**

- **输入格式**
有多行（可能有上百行，尽量优化代码），每行一个数字N，最后一行是0
- **输出格式**
对每一行的数字N，输出针对N的方案数
直到没有数字


>输入样例
10
4
0

>输出样例
2
0

## 思路：
 **利用递归分治算法，
实际上进行的查找就像二叉树一样（去除偶数项或去除奇数项之后再去除，直到剩余的项数少于等于3项）
一直递归，其中如果有递归到数字之前计算过的，直接调用哈希表，提高效率，避免重复运算**

```C++
#include <iostream>
#include <map>
using namespace std;
map<unsigned int,unsigned int>memo;

int calculate(unsigned int n){
//所谓分治，就是一直分，分后计算再合，至于已经算了的，存哈希表方便后边调出来
    unsigned int odd,even;
    if(n<=3){
        return n==3?1:0;
    }
    if(memo.find(n)!=memo.end()){
        return memo[n];
    }//运用哈希表进行查询，有就直接返回这个值就好
    
    even=calculate(n/2);
    odd=calculate((n+1)/2);
    unsigned int result=even+odd;
    memo[n]=result;//把已计算过的结果放到哈希表里面，方便后续用
    return result;
}

int main(){
    unsigned int n;
    while(cin>>n&&n!=0){
        cout<<calculate(n)<<endl;
    }
    return 0;
}
```
# 不巡逻的士兵

```C++
#include <iostream>
#include <map>
using namespace std;
map<unsigned int,unsigned int>memo;

int calculate(unsigned int n){

    unsigned int odd,even;
    if(n<3){
        return n;
    }
    if(n==3){
    	return 0;
	}
	else{
    if(memo.find(n)!=memo.end()){
        return memo[n];
    }
    
    even=calculate(n/2);
    odd=calculate((n+1)/2);
    unsigned int result=even+odd;
    memo[n]=result;
    return result;
	}
}

int main(){
    unsigned int n;
    while(cin>>n&&n!=0){
        cout<<calculate(n)<<endl;
    }
    return 0;
}
```

<!--stackedit_data:
eyJoaXN0b3J5IjpbMTgzMTY2MjEzOCwtMTg3NzkyMzUxNiwtMT
Q1MjA4NTYxNiw4ODUxNjM3Miw1OTAwODM1NjZdfQ==
-->