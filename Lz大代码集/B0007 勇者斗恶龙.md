# 勇者斗恶龙 
- **有n个头的恶龙，你希望雇一些骑士把它杀死（即砍掉所有头）。村里有ｍ个骑士可以雇佣，一个能力值为x的骑士可以砍掉恶龙 一个直径不超过x的头，且需要支付x个金币。如何雇佣骑士才能砍掉恶龙的所有头，且需要支付的金币最少？注意，一个骑士只能砍一个头（且不能被雇佣两次）**

**输入格式：**
多组数据，每组数据的第一行为正整数n和m(1<=n,m<=200000)
以下n行每行为一个整数，即恶龙每个头的直径；
以下m行每行为 一个整数，即每个骑士的能力。
输入结束标志ｎ＝ｍ＝0;

**输出格式：**
每组数据，输出最少花费，
无解输出"Loowater is doomed!" 

**输入样例**
2 3 
5 
4
7 
8 
4
2 1
5 
5 
10 
0 0 
**输出样例** 
11
 Loowater is doomed!

- **基本思路**
	用两个数组存放龙和骑士，再用类指针去遍历对比以及计算

``` C++
#include <iostream>
#include <vector>
#include <algorithm>
#include <cstdio>
using namespace std;

int main() {
    int n, m;
    while (scanf("%d %d", &n, &m) == 2 && (n != 0 || m != 0)) {
        vector<int> heads(n);
        vector<int> knights(m);
        for (int i = 0; i < n; ++i) {
            scanf("%d", &heads[i]);
        }
        for (int i = 0; i < m; ++i) {
            scanf("%d", &knights[i]);
        }
        
        if (n > m) {
            printf("Loowater is doomed!\n");
            continue;
        }
        //预判
        
        sort(heads.begin(), heads.end());
        sort(knights.begin(), knights.end());
        
        int total_cost = 0;
        int i = 0, j = 0;
        
        while (i < n && j < m)//这样子设置比较的前提条件 
        {
            if (knights[j] >= heads[i]) {
                total_cost += knights[j];
                ++i;
                ++j;
            } else {
                ++j;0
            }
        }
        
        if (i == n) {
            printf("%d\n", total_cost);
        } else {
            printf("Loowater is doomed!\n");
        }
    }
    //好好记住，这样的类指针遍历！
    return 0;
}
<!--stackedit_data:
eyJoaXN0b3J5IjpbMTQyMDA1NTk3NiwtMTc3NTkwMjU3NywxMT
A5NjM3MTEsLTQzMTYxNjI2M119
-->